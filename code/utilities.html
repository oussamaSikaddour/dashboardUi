<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css"
      integrity="sha512-SzlrxWUlpfuzQ+pcUCosxcglQRNAq/DZjVsC0lE40xsADsfeQoEypE+enwcOiGjk/bSuGGKHEyjSoQ1zVisanQ=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />

    <title>Utilities | DashboardUi</title>

    <link rel="icon" type="image/icon" href="assets/img/Logo.ico" />
  </head>
  <body>
    <!-- HEADER -->
    <header class="header">
      <nav class="nav" aria-labelledby="main-nav">
        <h2 id="main-nav" class="sr-only">Main navigation</h2>
        <div class="nav__addons" role="menubar">
          <a
            class="nav__logo"
            href="index.html"
            tabindex="0"
            aria-label="Description of the overall image"
          >
            <img src="assets/img/Logo.png" alt="app Logo" />
          </a>
        </div>
      </nav>
    </header>

    <!-- PHONE NAV TOGGLE -->
    <button
      id="showPhoneNav-btn"
      class="button nav__humb"
      aria-expanded="false"
      aria-controls="options"
      aria-label="Show phone navigation"
      aria-labelledby="showPhoneNav-btn"
    >
      <span></span>
      <span></span>
    </button>

    <!-- PHONE NAV -->
    <nav class="nav--phone" aria-labelledby="main-nav-phone">
      <h2 id="main-nav-phone" class="sr-only">Main navigation for phone</h2>
      <ul class="nav__items" id="options" hidden>
        <li class="nav__item" role="none">
          <a
            class="nav__link"
            href="index.html"
            aria-current="page"
            tabindex="0"
            role="menuitem"
            >Home</a
          >
        </li>
      </ul>
    </nav>

    <!-- MAIN CONTENT -->
    <main class="container container--fit">
      <h1>Js Utilities</h1>

      <section class="section" id="badges-section">
        <h2>Aria.js — Accessibility Utility</h2>

        <pre><code class="language--js">
// Utility function to update ARIA-related attributes for accessibility
export const setAriaAttributes = (hidden, tabindex, element) => {
  // `aria-hidden` determines if the element should be ignored by assistive technologies
  element.setAttribute("aria-hidden", hidden);
  // `tabindex` controls whether the element is focusable and its tab order
  element.setAttribute("tabindex", tabindex);
};
</code></pre>

        <h3>Parameters</h3>
        <ul>
          <li>
            <strong><code>hidden</code></strong> — A boolean or string value
            determining whether the element should be hidden from screen readers
            (<code>true</code> or <code>"true"</code> hides the element).
          </li>
          <li>
            <strong><code>tabindex</code></strong> — A numeric value indicating
            the element’s position in the tab order. Common values:
            <ul>
              <li><code>0</code> — focusable in natural order</li>
              <li><code>-1</code> — focusable only via JavaScript</li>
              <li><code>1+</code> — custom tab order (not recommended)</li>
            </ul>
          </li>
          <li>
            <strong><code>element</code></strong> — The DOM element whose
            accessibility attributes will be updated.
          </li>
        </ul>

        <h3>Behavior</h3>
        <p>
          This utility updates both attributes directly on the given element. It
          is typically used whenever a UI component is opened, closed, shown, or
          hidden to ensure proper accessibility synchronization.
        </p>

        <h3>Example Usage</h3>
        <pre><code class="language--js">
import { setAriaAttributes } from './utils/setAriaAttributes.js';

// Hide an element from assistive tech and remove from tab flow
const modal = document.querySelector('.modal');
setAriaAttributes(true, -1, modal);

// Make the modal visible and focusable again
setAriaAttributes(false, 0, modal);
  </code></pre>

        <h3>Integration Notes</h3>
        <ul>
          <li>
            Use this helper when toggling visibility of dynamic components such
            as modals, drawers, dropdowns, or forms.
          </li>
          <li>
            Ensures that inactive or hidden panels do not confuse screen readers
            or intercept keyboard focus.
          </li>
          <li>
            Keeps your application compliant with WCAG and ARIA accessibility
            standards.
          </li>
        </ul>

        <h2>DispatchCustomEvent.js — Custom Event Dispatcher</h2>

        <p>
          The <code>dispatchCustomEvent</code> utility provides a clean and
          consistent way to emit custom events across the application. It
          simplifies communication between components without requiring tight
          coupling.
        </p>

        <h3>Purpose</h3>
        <ul>
          <li>
            Emits a <code>CustomEvent</code> with optional data
            (<code>detail</code>).
          </li>
          <li>
            Allows events to bubble through the DOM and cross Shadow DOM
            boundaries.
          </li>
          <li>
            Used to notify other modules about UI state changes or interactions.
          </li>
        </ul>
        <pre><code class="language--js">
  // dispatchEvent.js

export const dispatchCustomEvent = (eventName, detail = undefined, target = document) => {

  target.dispatchEvent(new CustomEvent(eventName, {
    detail,
    bubbles: true,   // event travels up
    composed: true,  // crosses Shadow DOM boundary
  }));


};


// on.js
export const on = (eventName, callback, options = {}, target = document) => {

  const handler = (e) => callback(e.detail, e);

  target.addEventListener(eventName, handler, options);

  // return off() cleanup
  return () => {
    target.removeEventListener(eventName, handler, options);
  };


};
  </code></pre>

        <h3>Parameters</h3>
        <ul>
          <li>
            <strong><code>eventName</code></strong> — The name (string) of the
            event to dispatch.
          </li>
          <li>
            <strong><code>detail</code></strong> — Optional data object sent
            along with the event.
          </li>
          <li>
            <strong><code>target</code></strong> — The DOM element that emits
            the event (default: <code>document</code>).
          </li>
        </ul>

        <h3>Behavior</h3>
        <p>
          The function creates a new <code>CustomEvent</code> and dispatches it
          from the provided target. The event bubbles up the DOM tree and can
          pass through Shadow DOMs because <code>bubbles</code> and
          <code>composed</code> are both set to <code>true</code>.
        </p>

        <h3>Example Usage</h3>
        <pre><code class="language--js">
import { dispatchCustomEvent } from './utils/dispatchEvent.js';

// Dispatch an event with extra data
dispatchCustomEvent('user:loggedIn', { username: 'Alex' });

// Dispatch an event from a specific element
const button = document.querySelector('#save-btn');
dispatchCustomEvent('button:clicked', { id: 42 }, button);
 
</code></pre>

        <h3>Integration Notes</h3>
        <ul>
          <li>
            Works well with the <code>on()</code> utility to handle events
            cleanly.
          </li>
          <li>
            Ideal for creating decoupled communication between modules and
            components.
          </li>
          <li>
            Useful in modal, form, or navigation systems for signaling state
            changes.
          </li>
        </ul>

        <h2>
          Utility Functions — <code>debounce()</code> &
          <code>getBackgroundColor()</code>
        </h2>

        <p>
          This utility module contains two common helpers used across the UI
          system:
          <strong><code>debounce()</code></strong> for optimizing frequent
          function calls, and
          <strong><code>getBackgroundColor()</code></strong> for retrieving the
          visual color of any DOM element.
        </p>

        <hr />

        <!-- debounce -->
        <article class="doc-subsection">
          <h3>1. <code>debounce()</code> — Delay Function Execution</h3>

          <p>
            The <code>debounce()</code> function ensures that a given callback
            is executed only after a specified delay (<code>wait</code>) has
            passed since the last time it was invoked. It’s ideal for optimizing
            high-frequency events such as typing, resizing, or scrolling.
          </p>

          <h4>Source Code</h4>
          <pre><code class="language--js">
export const debounce = (func, wait) => {
  let timeout;
  return (...args) => {
    clearTimeout(timeout); // Clear any previously set timer
    timeout = setTimeout(() => func?.apply(this, args), wait); // Delay function execution
  };
};
    </code></pre>

          <h4>Parameters</h4>
          <ul>
            <li>
              <strong><code>func</code></strong> — The function to be delayed.
            </li>
            <li>
              <strong><code>wait</code></strong> — The time in milliseconds to
              wait before invoking <code>func</code>.
            </li>
          </ul>

          <h4>Behavior</h4>
          <ul>
            <li>
              If <code>debounce()</code> is called repeatedly within the
              <code>wait</code> interval, the timer resets.
            </li>
            <li>
              Only the last call after the quiet period triggers the function
              execution.
            </li>
            <li>
              Useful for preventing rapid function calls in UI interactions.
            </li>
          </ul>

          <h4>Example Usage</h4>
          <pre><code class="language--js">
import { debounce } from './utils/debounce.js';

const logResize = () => console.log('Window resized!');
window.addEventListener('resize', debounce(logResize, 300));
    </code></pre>

          <h4>Use Cases</h4>
          <ul>
            <li>
              Search inputs — delay network requests until user stops typing.
            </li>
            <li>Window resize events — limit recalculations.</li>
            <li>
              Scroll listeners — prevent excessive reflows or paint operations.
            </li>
          </ul>
        </article>

        <hr />

        <!-- getBackgroundColor -->
        <article class="doc-subsection">
          <h3>
            2. <code>getBackgroundColor()</code> — Get Element Background Color
          </h3>

          <p>
            The <code>getBackgroundColor()</code> function retrieves the
            computed background color of a given DOM element using the browser’s
            computed styles API.
          </p>

          <h4>Source Code</h4>
          <pre><code class="language--js">
export const getBackgroundColor = (element) => {
  const computedStyle = window.getComputedStyle(element); // Gets all computed styles
  return computedStyle.backgroundColor; // Returns just the background color
};
    </code></pre>

          <h4>Parameters</h4>
          <ul>
            <li>
              <strong><code>element</code></strong> — A reference to a valid DOM
              element whose background color should be retrieved.
            </li>
          </ul>

          <h4>Behavior</h4>
          <p>
            The function uses <code>window.getComputedStyle()</code> to obtain
            the current computed styles for the provided element, returning its
            <code>background-color</code> value as a string (e.g.
            <code>rgb(255, 255, 255)</code>).
          </p>

          <h4>Example Usage</h4>
          <pre><code class="language--js">
import { getBackgroundColor } from './utils/colorUtils.js';

const button = document.querySelector('.btn');
console.log(getBackgroundColor(button)); // → "rgb(8, 126, 164)"
    </code></pre>

          <h4>Integration Notes</h4>
          <ul>
            <li>
              Useful for dynamic UI theming and animations based on current
              colors.
            </li>
            <li>
              Can be combined with CSS transitions to match background hues.
            </li>
            <li>
              Non-computed inline styles (e.g.
              <code>style="background-color:..."</code>) are also resolved
              correctly.
            </li>
          </ul>
        </article>
        <h2>Accessibility Utilities — <code>toggleInert()</code> Family</h2>

        <p>
          The <code>toggleInert()</code> utilities are designed to manage
          focusability and interactivity of elements when modals, dialogs, or
          overlays are opened. They use the native <code>inert</code> attribute
          when available, and fall back to ARIA attributes and pointer disabling
          for browsers without native support.
        </p>

        <hr />

        <h3>1. <code>toggleInert()</code> — Core Focus Lock Handler</h3>

        <p>
          The <code>toggleInert()</code> function enables or disables user
          interaction and accessibility focus for a given DOM element and all
          its descendants. It is the foundation for all the other
          <code>toggleInert*</code> functions.
        </p>

        <h4>Source Code</h4>
        <pre><code class="language--js">

    
const toggleInert = (element, state = false) => {
  if (!element) return; // Safety check

  // Check if the browser supports native inert
  const supportsInert = 'inert' in HTMLElement.prototype;

  if (supportsInert) {
    state ? element.setAttribute('inert', '') : element.removeAttribute('inert');
  } else {
    // Fallback for browsers without inert support
    if (state) {
      element.setAttribute('aria-hidden', 'true'); // Hide from screen readers
      element.style.pointerEvents = 'none';        // Disable mouse interaction

      // Disable focus on all descendants
      element.querySelectorAll('a, button, input, textarea, select, [tabindex]').forEach((child) => {
        child.dataset.oldTabindex = child.getAttribute('tabindex'); // Save original tabindex
        child.setAttribute('tabindex', '-1');
      });
    } else {
      element.removeAttribute('aria-hidden');
      element.style.pointerEvents = '';

      // Restore original tabindex for descendants
      element.querySelectorAll('[data-old-tabindex]').forEach((child) => {
        const old = child.dataset.oldTabindex;
        if (old !== null) {
          child.setAttribute('tabindex', old);
        } else {
          child.removeAttribute('tabindex');
        }
        delete child.dataset.oldTabindex;
      });
    }
  }
};


/**
 * toggleInertWhenState
 * Conditionally toggles the `inert` attribute based on whether the element
 * has a given class name. You can invert this logic via `invertState`.
 *
 * Example: toggleInertWhenState(modal, 'open') → inert ON if modal is open.
 */

export const toggleInertWhenState = (element, className, invertState = false) => {
  if (!element) return;
  const isActive = element.classList.contains(className);
  toggleInert(element, invertState ? !isActive : isActive);
};
/**
 * toggleInertForChildElement
 * Applies the same logic as toggleInertWhenState but targets a *child* element.
 * Useful when you want a child to become inert based on the parent's state.
 */
export const toggleInertForChildElement = (parent, child, className, invertState = false) => {
  if (!parent || !child) return;
  const isActive = parent.classList.contains(className);
  toggleInert(child, invertState ? !isActive : isActive);
};

/**
 * toggleInertForAllExceptOpenedElement
 * Makes all direct children of &lt;body&gt; inert, *except* the specified element.
 * Often used in modals/dialogs to trap focus and prevent interaction outside.
 */


export const toggleInertForAllExceptOpenedElement = (openedElement, className, invertState = false) => {
  if (!openedElement) return;
 
  
  const isActive = openedElement.classList.contains(className);
  const bodyChildren = Array.from(document.body.children);

  bodyChildren.forEach((child) => {
    if (child !== openedElement) {
      toggleInert(child, invertState ? !isActive : isActive);
    }
  });
};
  </code></pre>

        <h4>Parameters</h4>
        <ul>
          <li>
            <strong><code>element</code></strong> — The DOM element to modify.
          </li>
          <li>
            <strong><code>state</code></strong> — Boolean;
            <code>true</code> disables interactivity and focus,
            <code>false</code> restores it.
          </li>
        </ul>

        <h4>Behavior</h4>
        <ul>
          <li>
            Uses <code>inert</code> when supported natively by the browser.
          </li>
          <li>
            Falls back to <code>aria-hidden="true"</code> and
            <code>pointer-events: none</code> otherwise.
          </li>
          <li>
            Temporarily removes <code>tabindex</code> from focusable children
            and restores them when re-enabled.
          </li>
        </ul>

        <h4>Example Usage</h4>
        <pre><code class="language--js">
// Disable interaction for the background when modal is open
const backdrop = document.querySelector('.page-content');
toggleInert(backdrop, true);
    </code></pre>

        <h3>
          2. <code>toggleInertWhenState()</code> — Inert Based on Class State
        </h3>

        <p>
          This helper toggles <code>inert</code> automatically depending on
          whether a given element has a specified class name (e.g.,
          <code>open</code>). Optionally, you can invert the logic using
          <code>invertState</code>.
        </p>

        <h4>Source Code</h4>
        <pre><code class="language--js">
export const toggleInertWhenState = (element, className, invertState = false) => {
  if (!element) return;
  const isActive = element.classList.contains(className);
  toggleInert(element, invertState ? !isActive : isActive);
};
    </code></pre>

        <h4>Parameters</h4>
        <ul>
          <li>
            <strong><code>element</code></strong> — Target element whose
            interactivity is toggled.
          </li>
          <li>
            <strong><code>className</code></strong> — The class that determines
            the active/inactive state.
          </li>
          <li>
            <strong><code>invertState</code></strong> — Optional; reverses the
            logic (default <code>false</code>).
          </li>
        </ul>

        <h4>Example Usage</h4>
        <pre><code class="language--js">
const modal = document.querySelector('.modal');
toggleInertWhenState(modal, 'open');
// → modal becomes inert when it has class "open"
    </code></pre>

        <h4>Use Cases</h4>
        <ul>
          <li>Auto-disable background content when a modal is active.</li>
          <li>Dynamic focus management tied to element state.</li>
          <li>
            Works with CSS transitions that toggle <code>open</code> classes.
          </li>
        </ul>

        <hr />

        <h3>
          3. <code>toggleInertForChildElement()</code> — Inert for Nested Child
        </h3>

        <p>
          Applies the same logic as <code>toggleInertWhenState()</code>, but
          targets a <em>child element</em> instead of the parent itself. Ideal
          when you want to lock interaction on a nested section while the parent
          element changes state.
        </p>

        <h4>Source Code</h4>
        <pre><code class="language--js">
export const toggleInertForChildElement = (parent, child, className, invertState = false) => {
  if (!parent || !child) return;
  const isActive = parent.classList.contains(className);
  toggleInert(child, invertState ? !isActive : isActive);
};
    </code></pre>

        <h4>Parameters</h4>
        <ul>
          <li>
            <strong><code>parent</code></strong> — The parent element whose
            class state controls the toggle.
          </li>
          <li>
            <strong><code>child</code></strong> — The child element to make
            inert or interactive.
          </li>
          <li>
            <strong><code>className</code></strong> — The class name that
            determines the state.
          </li>
          <li>
            <strong><code>invertState</code></strong> — Optional boolean to
            reverse the logic.
          </li>
        </ul>

        <h4>Example Usage</h4>
        <pre><code class="language--js">
toggleInertForChildElement(
  document.querySelector('.modal'),
  document.querySelector('.modal__overlay'),
  'open'
);
    </code></pre>

        <h3>
          4. <code>toggleInertForAllExceptOpenedElement()</code> — Focus Trap
          for Dialogs
        </h3>

        <p>
          This function applies <code>inert</code> to all direct children of
          <code>&lt;body&gt;</code> except for a specified open element. It’s
          commonly used for modal dialogs to prevent background interaction and
          visually trap focus within the active component.
        </p>

        <h4>Source Code</h4>
        <pre><code class="language--js">
export const toggleInertForAllExceptOpenedElement = (openedElement, className, invertState = false) => {
  if (!openedElement) return;
 
  const isActive = openedElement.classList.contains(className);
  const bodyChildren = Array.from(document.body.children);

  bodyChildren.forEach((child) => {
    if (child !== openedElement) {
      toggleInert(child, invertState ? !isActive : isActive);
    }
  });
};
    </code></pre>

        <h4>Parameters</h4>
        <ul>
          <li>
            <strong><code>openedElement</code></strong> — The element that
            remains interactive (e.g., a modal).
          </li>
          <li>
            <strong><code>className</code></strong> — The class name that
            indicates the open/active state.
          </li>
          <li>
            <strong><code>invertState</code></strong> — Optional boolean to
            reverse the logic.
          </li>
        </ul>

        <h4>Example Usage</h4>
        <pre><code class="language--js">
// Disable all background layers when a modal is open
toggleInertForAllExceptOpenedElement(document.querySelector('.modal'), 'open');
    </code></pre>

        <h4>Use Cases</h4>
        <ul>
          <li>Trap focus within a modal or drawer.</li>
          <li>Prevent background scrolling or clicking during overlays.</li>
          <li>
            Enforce accessibility by isolating active interactive regions.
          </li>
        </ul>

        <h2>Keyboard Navigation — <code>handleKeyEvents()</code></h2>

        <p>
          The <code>handleKeyEvents()</code> utility provides standardized
          keyboard behavior for focusable components such as menus, lists, or
          comboboxes. It handles directional keys (<code>ArrowUp</code> /
          <code>ArrowDown</code>), activation keys (<code>Enter</code> /
          <code>Space</code>), and dismissal (<code>Escape</code>), ensuring
          accessible navigation with keyboard controls.
        </p>

        <hr />

        <h3>Source Code</h3>
        <pre><code class="language--js">
export const handleKeyEvents = (
  event,
  index,
  keyFunctionHandler = null,
  htmlElementsArray,
  escapeFunction = null
) => {
  const { key } = event;
  const lastIndex = htmlElementsArray.length - 1;

  // Early handling for Escape
  if (key === 'Escape' && escapeFunction) {
    event.preventDefault();
    escapeFunction();
    return;
  }

  // Early handling for Enter / Space
  if ((key === 'Enter' || key === ' ') && keyFunctionHandler) {
    event.preventDefault();
    keyFunctionHandler();
    return;
  }

  // Navigation handling
  const actions = {
    ArrowDown: () => {
      if (index &lt; lastIndex) htmlElementsArray[index + 1].focus();
    },
    ArrowUp: () => {
      if (index > 0) htmlElementsArray[index - 1].focus();
    },
    Home: () => htmlElementsArray[0].focus(),
    End: () => htmlElementsArray[lastIndex].focus(),
  };

  if (actions[key]) {
    event.preventDefault();
    actions[key]();
  }
};
  </code></pre>

        <hr />

        <h3>Parameters</h3>
        <ul>
          <li>
            <strong><code>event</code></strong> — The keyboard event object
            (<code>KeyboardEvent</code>) captured from a
            <code>keydown</code> listener.
          </li>
          <li>
            <strong><code>index</code></strong> — The numeric index of the
            currently focused element within <code>htmlElementsArray</code>.
          </li>
          <li>
            <strong><code>keyFunctionHandler</code></strong> — Optional callback
            function executed when the user presses <code>Enter</code> or
            <code>Space</code>.
          </li>
          <li>
            <strong><code>htmlElementsArray</code></strong> — Array (or
            NodeList) of focusable elements within the interactive component.
          </li>
          <li>
            <strong><code>escapeFunction</code></strong> — Optional callback
            function executed when the user presses <code>Escape</code> (usually
            to close the component).
          </li>
        </ul>

        <hr />

        <h3>Key Behavior</h3>
        <ul>
          <li><strong>ArrowDown</strong> — Moves focus to the next item.</li>
          <li><strong>ArrowUp</strong> — Moves focus to the previous item.</li>
          <li><strong>Home</strong> — Moves focus to the first element.</li>
          <li><strong>End</strong> — Moves focus to the last element.</li>
          <li>
            <strong>Enter / Space</strong> — Triggers
            <code>keyFunctionHandler()</code>.
          </li>
          <li>
            <strong>Escape</strong> — Triggers <code>escapeFunction()</code>.
          </li>
        </ul>

        <hr />

        <h3>Example Usage</h3>
        <pre><code class="language--js">
// Example: accessible menu navigation
const menuItems = document.querySelectorAll('.menu-item');

menuItems.forEach((item, index) => {
  item.addEventListener('keydown', (event) => {
    handleKeyEvents(
      event,
      index,
      () => item.click(), // Handle Enter/Space
      menuItems,
      () => menu.classList.remove('open') // Handle Escape
    );
  });
});
  </code></pre>

        <hr />

        <h3>Accessibility Notes</h3>
        <ul>
          <li>Prevents default browser scrolling on arrow key presses.</li>
          <li>
            Maintains a logical tab order and focus flow using
            <code>focus()</code>.
          </li>
          <li>
            Ensures consistent keyboard support across interactive components.
          </li>
          <li>
            Ideal for use with listboxes, dropdown menus, and combobox items.
          </li>
        </ul>

        <h2>Element Position &amp; Dimensions Utility</h2>

        <p>
          The <code>Element Position &amp; Dimensions Utility</code> provides a
          modular, SRP-compliant way to retrieve, calculate, and apply element
          positions and dimensions in the DOM. Each helper function handles a
          single, well-defined responsibility — improving readability,
          maintainability, and testability.
        </p>

        <h3>Key Responsibilities</h3>
        <ul>
          <li>Retrieve DOM elements safely.</li>
          <li>Collect layout and viewport data.</li>
          <li>Calculate available space and best-fit positioning.</li>
          <li>Apply computed positions to floating UI elements.</li>
          <li>Automatically handle scroll offset and viewport boundaries.</li>
        </ul>

        <pre>
          <code class="language--js">
/**
 * Element Position & Dimensions Utility (SRP Compliant)
 * -----------------------------------------------------
 * Utilities for safely retrieving, calculating, and setting
 * element position, visibility, and dimensions.
 * Each function respects the Single Responsibility Principle (SRP).
 */

// ==================== CORE FUNCTIONS ====================

/**
 * Safely get a DOM element (SRP: Element Retrieval)
 * @param {string|Element} element - CSS selector or DOM element
 * @returns {Element|null} - DOM element or null
 */
function getElement(element) {
  if (!element) {
    console.warn('getElement: No element provided');
    return null;
  }

  if (typeof window === 'undefined' || typeof document === 'undefined') {
    console.warn('getElement: DOM not available');
    return null;
  }

  try {
    return typeof element === 'string'
      ? document.querySelector(element)
      : element instanceof Element
        ? element
        : null;
  } catch (error) {
    console.error('getElement: Invalid element', error);
    return null;
  }
}

/**
 * Collect geometry and viewport data (SRP: Layout Data Collection)
 * @param {Element} targetEl - The reference element
 * @param {Element} floatingEl - The element to position
 * @returns {Object} - Layout data (rects, viewport, scroll)
 */
function getLayoutData(targetEl, floatingEl) {
  const targetRect = targetEl.getBoundingClientRect();
  const floatRect = floatingEl.getBoundingClientRect();
  const { innerWidth: vw, innerHeight: vh } = window;
  const { scrollX, scrollY } = window;

  return {
    targetRect,
    floatRect,
    viewport: { width: vw, height: vh },
    scroll: { x: scrollX, y: scrollY }
  };
}

/**
 * Check available space for positioning (SRP: Space Availability Calculation)
 * @param {DOMRect} targetRect
 * @param {DOMRect} floatRect
 * @param {Object} viewport
 * @param {number} offset
 * @returns {Object} - Boolean flags for top/bottom/left/right
 */
function calculateFitAvailability(targetRect, floatRect, viewport, offset) {
  return {
    top: targetRect.top >= floatRect.height + offset,
    bottom: targetRect.bottom + floatRect.height + offset &lt;= viewport.height,
    right: targetRect.right + floatRect.width + offset &lt;= viewport.width,
    left: targetRect.left - floatRect.width - offset >= 0
  };
}

/**
 * Compute the optimal position for the floating element (SRP: Position Strategy)
 * @param {DOMRect} targetRect
 * @param {DOMRect} floatRect
 * @param {Object} viewport
 * @param {number} offset
 * @returns {Object} - { top, left, name } position object
 */
function calculatePosition(targetRect, floatRect, viewport, offset) {
  const fits = calculateFitAvailability(targetRect, floatRect, viewport, offset);
  
  // Default position: top
  let position = { 
    top: targetRect.top - floatRect.height - offset,
    left: targetRect.left + (targetRect.width - floatRect.width) / 2,
    name: "top"
  };

  // Adjust vertical position if top doesn't fit
  if (!fits.top && fits.bottom) {
    position.top = targetRect.bottom + offset;
    position.name = "bottom";
  }

  // Adjust horizontal position if out of bounds
  if (position.left &lt; 0) {
    position.left = offset;
    position.name += "-left";
  } else if (position.left + floatRect.width > viewport.width) {
    position.left = viewport.width - floatRect.width - offset;
    position.name += "-right";
  }

  // Fallback to side placements if neither top nor bottom fit
  if (!fits.top && !fits.bottom) {
    if (fits.right) {
      position.left = targetRect.right + offset;
      position.top = targetRect.top + (targetRect.height - floatRect.height) / 2;
      position.name = "right";
    } else if (fits.left) {
      position.left = targetRect.left - floatRect.width - offset;
      position.top = targetRect.top + (targetRect.height - floatRect.height) / 2;
      position.name = "left";
    }
  }

  return position;
}

/**
 * Apply calculated position to the floating element (SRP: DOM Manipulation)
 * @param {Element} floatingEl - The element to position
 * @param {Object} position - { top, left, name }
 * @param {Object} scroll - { x, y }
 */
function applyPosition(floatingEl, position, scroll) {
  if (!floatingEl || !position) return;

  floatingEl.style.position = "absolute";
  floatingEl.style.top = `${position.top + scroll.y}px`;
  floatingEl.style.left = `${position.left + scroll.x}px`;
  floatingEl.dataset.position = position.name;
}

// ==================== MAIN EXPORT ====================

/**
 * Position one element relative to another.
 * Automatically adjusts to fit within the viewport.
 *
 * @param {string|Element} targetEl - The reference element or selector.
 * @param {string|Element} floatingEl - The floating element or selector.
 * @param {number} [offset=8] - Space (in px) between the elements.
 */
export function positionRelativeTo(targetEl, floatingEl, offset = 8) {
  const targetElement = getElement(targetEl);
  const floatingElement = getElement(floatingEl);
  
  if (!targetElement || !floatingElement) {
    console.warn('positionRelativeTo: Invalid target or floating element');
    return;
  }

  const layoutData = getLayoutData(targetElement, floatingElement);
  const position = calculatePosition(
    layoutData.targetRect, 
    layoutData.floatRect, 
    layoutData.viewport, 
    offset
  );
  
  applyPosition(floatingElement, position, layoutData.scroll);
}

// ==================== OPTIONAL EXPORTS ====================
// (Useful for testing or external use)

export {
  getElement,
  getLayoutData,
  calculateFitAvailability,
  calculatePosition,
  applyPosition
};


          </code>
        </pre>
        <hr />

        <h3>Core Functions</h3>

        <h4><code>getElement(element)</code></h4>
        <p>
          Safely retrieves a DOM element from either a CSS selector or a direct
          reference. Returns <code>null</code> if the element or DOM environment
          is unavailable.
        </p>
        <pre><code class="language--js">
const el = getElement('.tooltip');
  </code></pre>
        <ul>
          <li>
            <strong>Parameter:</strong> <code>element</code> — string or Element
            reference.
          </li>
          <li><strong>Returns:</strong> DOM element or <code>null</code>.</li>
        </ul>

        <hr />

        <h4><code>getLayoutData(targetEl, floatingEl)</code></h4>
        <p>
          Collects geometric and viewport data for both the target and the
          floating elements. Returns bounding rectangles, viewport dimensions,
          and current scroll position.
        </p>
        <pre><code class="language--js">
const layout = getLayoutData(button, tooltip);
  </code></pre>
        <ul>
          <li>
            Includes <code>targetRect</code>, <code>floatRect</code>,
            <code>viewport</code>, and <code>scroll</code> data.
          </li>
        </ul>

        <hr />

        <h4>
          <code
            >calculateFitAvailability(targetRect, floatRect, viewport,
            offset)</code
          >
        </h4>
        <p>
          Determines whether there's enough available space around the target
          element to position the floating element above, below, left, or right.
        </p>
        <ul>
          <li>
            Returns boolean flags: <code>top</code>, <code>bottom</code>,
            <code>left</code>, <code>right</code>.
          </li>
        </ul>
        <pre><code class="language--js">
const fits = calculateFitAvailability(targetRect, floatRect, viewport, 8);
  </code></pre>

        <hr />

        <h4>
          <code
            >calculatePosition(targetRect, floatRect, viewport, offset)</code
          >
        </h4>
        <p>
          Computes the best possible position for the floating element,
          prioritizing top placement, then bottom, left, or right, depending on
          available space.
        </p>
        <ul>
          <li>Returns an object: <code>{ top, left, name }</code></li>
          <li>
            Includes auto-adjustment for viewport overflow and offset spacing.
          </li>
        </ul>
        <pre><code class="language--js">
const position = calculatePosition(targetRect, floatRect, viewport, 8);
  </code></pre>

        <hr />

        <h4><code>applyPosition(floatingEl, position, scroll)</code></h4>
        <p>
          Applies the computed coordinates to the floating element using
          absolute positioning. It also sets a
          <code>data-position</code> attribute (e.g., "top-right") for styling
          hooks.
        </p>
        <ul>
          <li>
            Respects current scroll position via <code>scroll.x</code> and
            <code>scroll.y</code>.
          </li>
          <li>
            Sets <code>style.top</code> and <code>style.left</code> in pixels.
          </li>
        </ul>

        <hr />

        <h3>Main Export</h3>

        <h4>
          <code>positionRelativeTo(targetEl, floatingEl, offset = 8)</code>
        </h4>
        <p>
          The primary exported function. Positions a floating element (e.g.,
          tooltip or dropdown) relative to a target element while ensuring it
          stays visible within the viewport.
        </p>
        <pre><code class="language--js">
positionRelativeTo('.button', '.tooltip', 8);
  </code></pre>

        <ul>
          <li><strong>targetEl:</strong> Selector or DOM element reference.</li>
          <li><strong>floatingEl:</strong> Element to be positioned.</li>
          <li>
            <strong>offset:</strong> (optional) Distance in pixels between
            elements. Default: <code>8</code>.
          </li>
        </ul>

        <hr />

        <h3>Optional Named Exports</h3>
        <ul>
          <li><code>getElement</code></li>
          <li><code>getLayoutData</code></li>
          <li><code>calculateFitAvailability</code></li>
          <li><code>calculatePosition</code></li>
          <li><code>applyPosition</code></li>
        </ul>

        <hr />

        <h3>Example Usage</h3>
        <pre><code class="language-js">
// Example: Positioning a tooltip below a button
const button = document.querySelector('.tooltip-button');
const tooltip = document.querySelector('.tooltip');

positionRelativeTo(button, tooltip, 10);
  </code></pre>

        <hr />

        <h3>Notes</h3>
        <ul>
          <li>
            Follows the Single Responsibility Principle (SRP) strictly — each
            function does one thing.
          </li>
          <li>
            Handles fallback behavior when top/bottom placement is not possible.
          </li>
          <li>
            Provides graceful handling of invalid elements or DOM
            unavailability.
          </li>
          <li>
            Useful for tooltips, dropdowns, popovers, context menus, and
            floating UI patterns.
          </li>
        </ul>
      </section>
    </main>

    <script type="module" src="js/main.js"></script>
  </body>
</html>
